#!/usr/bin/env ruby
# frozen_string_literal: true

require 'fileutils'
require 'byebug'
require 'aggredator/amqp'
require 'aggredator/api/v1'
require 'aggredator/app'
require 'bunny'


HOST = ENV.fetch('MQ_HOST', 'infra.rnds.local')
PORT = ENV.fetch('MQ_PORT', 5671)
VHOST = ENV.fetch('MQ_VHOST', nil)
# AUTH_MECHANISM = 'PLAIN'
AUTH_MECHANISM = 'EXTERNAL'

FileUtils.mkdir_p 'config/keys'

File.write('config/keys/cacert.pem', ENV.fetch('CA_CERT'))
File.write('config/keys/cert.pem', ENV.fetch('CLIENT_CERT'))
File.write('config/keys/key.pem', ENV.fetch('CLIENT_KEY'))

connection = Bunny.new(
  host:                'mq',
  tls:                 true,
  tls_cert:            'config/keys/cert.pem',
  tls_key:             'config/keys/key.pem',
  tls_ca_certificates: ['config/keys/cacert.pem']
)



connection.start
channel = connection.channel


queue = channel.queue('source', auto_delete: true)
dest_queue = channel.queue('destination', auto_delete: true)

consumer = Aggredator::AMQP::Consumer.new connection, queue.name

msg_stream = Queue.new
consumer.run msg_stream

publisher = Aggredator::AMQP::Publisher.new connection, Aggredator::AMQP::Domains.new(direct: '', test: 'test')

msg = msg_stream.pop

puts msg.properties
puts msg.headers
puts msg.payload
puts msg.body

msg = Aggredator::Api::V1::Ping.new({ message_id: 111, reply_to: :test }, {})
result = Aggredator::Dispatcher::Result.new("mq://test@#{dest_queue.name}", msg)

future = publisher.publish result

sleep 15

future.then do
  puts 'completed'
end.rescue do
  puts 'failed'
end

